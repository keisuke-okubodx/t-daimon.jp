const EXAMPLES = {
  "標準入力/標準出力": "",
  "標準出力": "\"\"\"\n標準出力\n標準入力は「表示する」関数を使用します.\n「表示する」関数はPythonにおけるprintに相当します.\n------------------------------------------------------------------\n|表示する(*オブジェクト, 区切り=\" \", 末尾=\"\\n\", フラッシュ=False)|\n|・オブジェクト：コンソールに表示する値                          |\n|・区切り：値の区切り文字列                                      |\n|・末尾：表示する値の末尾の文字列                                |\n|・フラッシュ：出力をバッファに留めるかを指定する値              |\n------------------------------------------------------------------\n\"\"\"\n表示する(\"Hello World!\")\n\n表示する(\"A\",\"B\",\"C\",区切り=\"-\")\n\n表示する(\"こんにちは\",末尾=\"?\")\n\n表示する(\"a\",フラッシュ=False)\n表示する(\"b\",フラッシュ=True)#ここでは出力されません\n表示する(\"c\",フラッシュ=True)#ここでは出力されません\n表示する(\"d\",フラッシュ=True)#ここでは出力されません\n表示する(\"e\",フラッシュ=False)#この位置でまとめて出力されます",
  "標準入力": "\"\"\"\n標準入力\n標準入力は「入力」関数を使用します.「入力」関数はPythonにおけるinputに相当します.\n------------------------------------------------------------------\n| 関数 入力(メッセージ=\"\",*,入力形式=\"文字列\")                   |\n|・メッセージ：入力を受け取る際にコンソールに表示する文字列.     |\n|・入力形式：入力された値の変換形式.数値,文字列,論理値を指定可能.|\n------------------------------------------------------------------\n\"\"\"\n#標準入力を文字列として取得\nstr = 入力(\"文字列として読み込みます>>\")\n\n表示する(\"型:\",型(str))\n\n#標準入力を数値として取得\nnum = 入力(\"数値として読み込みます>>\",入力形式=\"数値\")\n\n表示する(\"型:\",型(num))\n\n#標準入力を論理値として取得\n#1,True,真の場合はTrue,それ以外はFalseに変換される\nbool = 入力(\"論理値として読み込みます>>\",入力形式=\"論理値\")\n表示する(\"型:\",型(bool))",
  "組み込み型": "",
  "データ構造": "\"\"\"\nデータ構造\n\"\"\"\narray = [1,2,3,4,5]#配列\ntuple = (1, 2, 3, 4)#タプル\ndict = {\"A\":10,\"B\":20,\"C\":30}#辞書\nset = {1,2,3,4,5}#集合\nobj = math#オブジェクト",
  "データ構造の可視化": "\"\"\"\nデータ構造の可視化\n可視化関数を用いると,データ構造の可視化方法を設定することができます.\nデータ構造の中身が数値以外の場合は無視されます.\n--------------------------------------------------------------------\n|関数 可視化(*ターゲット,種類=\"棒グラフ\",凡例=False)               |\n|・ターゲット：可視化するデータ構造.一度に複数設定できます.        |\n|・種類：棒グラフ,円グラフ,折れ線グラフ,散布図,ドーナツグラフ,     |\n|        レーダーチャートのいずれかを文字列として指定します.       |\n|        デフォルト値は棒グラフに設定されています.Noneに設定すると,|\n|        通常の表示形式に戻ります.                                 |\n|・凡例：グラフに凡例を表示するかどうかの設定.デフォルト値はFalse. |\n--------------------------------------------------------------------\n\"\"\"\n\n\"\"\"\n選択ソートを可視化する例.\nステップ実行にすると整列の様子を観察できます.\n\"\"\"\n\nA = [50,10,5,39,82,69,36,22,12,19]\n可視化(A)\n#可視化(A,種類=\"棒グラフ\")#可視化(A)と同じ\n#可視化(A,種類=\"円グラフ\")\n#可視化(A,種類=\"折れ線グラフ\")\n#可視化(A,種類=\"散布図\")\n#可視化(A,種類=\"ドーナツグラフ\")\n#可視化(A,種類=\"レーダーチャート\")\ni を 0 から 要素数(A) - 2 まで 1 ずつ増やしながら繰り返す:\n    tmp = i\n    j を i + 1 から 要素数(A) - 1 まで 1 ずつ増やしながら繰り返す:\n        もし A[j] < A[tmp] ならば:\n            tmp = j\n    A[i], A[tmp] = A[tmp], A[i]\n表示する(*A)",
  "数値": "\"\"\"\n数値\n\"\"\"\nx = 100#整数\ny = 3.14#浮動小数\n\n\"\"\"\n数値の演算\n\"\"\"\na = 5\nb = 3\n\n表示する(a,\"+\",b,\"=\",a + b)#和\n表示する(a,\"-\",b,\"=\",a - b)#差\n表示する(a,\"*\",b,\"=\",a * b)#積\n表示する(a,\"/\",b,\"=\",a / b)#商\n表示する(a,\"//\",b,\"=\",a // b)#商(切り捨て)\n表示する(a,\"%\",b,\"=\",a % b)#剰余\n表示する(a,\"**\",b,\"=\",a ** b)#ベキ乗(右結合で計算される)\n表示する(\"-\",a,\"=\",-a)#符号反転\n\n表示する(a,\">>\",b,\"=\",a >> b)#右シフト\n表示する(a,\"<<\",b,\"=\",a << b)#左シフト\n\n表示する(a,\"&\",b,\"=\",a & b)#ビット論理積\n表示する(a,\"|\",b,\"=\",a | b)#ビット論理和\n表示する(a,\"^\",b,\"=\",a ^ b)#ビット排他的論理和\n表示する(\"~\",a,\"=\",~a)#ビット否定\n\n表示する(a,\"==\",b,\"=\",a == b)#等価\n表示する(a,\"!=\",b,\"=\",a != b)#不等価\n表示する(a,\"<\",b,\"=\",a < b)#小なり\n表示する(a,\"<=\",b,\"=\",a <= b)#小なりイコール\n表示する(a,\">\",b,\"=\",a > b)#大なり\n表示する(a,\">=\",b,\"=\",a >= b)#大なりイコール",
  "文字列": "\"\"\"\n文字列\n\"\"\"\nあいさつ = \"おはようございます\"#文字列はダブルクォーテーションで囲んで記述します.\n表示する(あいさつ)\n\nmoji1 = \"abc\\ndef\"#\\nは改行文字を表します.\n表示する(moji1)\n\nmoji2 = \"abc\\\\ndef\"#\\記号で改行文字をエスケープできます.\n表示する(moji2)\n\n表示する(\"おはよう\" + \"ございます\")#+演算子で連結できます.\n\n#文字列はfor-in文で列挙可能です.\nあいさつ の要素 文字 について繰り返す:\n    表示する(文字)\n\n表示する(\"文字数 =\",あいさつ.文字数())#文字数を取得します.\n\n表示する(あいさつ[0])#添え字で文字を参照することができます.\n\n表示する(あいさつ[1:4])#部分文字列を取得します.\n\n表示する(あいさつ[::-1])#文字列を反転します.\n\ns = [*あいさつ]#文字の配列に分解します.\n表示する(s)\n\nx = 文字列(100)#オブジェクトを文字列に変換します.\n表示する(x)",
  "論理値": "\"\"\"\n論理値\n\"\"\"\n表示する(True)#論理値True\n表示する(False)#論理値False\n\n#比較演算の結果は論理値になる\na = 5\nb = 3\n表示する(a,\"==\",b,\"=\",a == b)#等価\n表示する(a,\"!=\",b,\"=\",a != b)#不等価\n表示する(a,\"<\",b,\"=\",a < b)#小なり\n表示する(a,\"<=\",b,\"=\",a <= b)#小なりイコール\n表示する(a,\">\",b,\"=\",a > b)#大なり\n表示する(a,\">=\",b,\"=\",a >= b)#大なりイコール\n\n\"\"\"\n論理値の演算\n論理値の演算に優先順位はありません.\n\"\"\"\n表示する(a,\"!=\",b,\"||\",a,\"<\",b,\"=\",a != b || a < b)#論理和\n表示する(a,\"!=\",b,\"&&\",a,\"<\",b,\"=\",a != b && a < b)#論理積\n表示する(a,\"!=\",b,\"or\",a,\"<\",b,\"=\",a != b or a < b)#論理和\n表示する(a,\"!=\",b,\"and\",a,\"<\",b,\"=\",a != b and a < b)#論理積\n表示する(\"!True =\",!True)#否定\n表示する(\"not True =\",not True)#否定",
  "配列": "\"\"\"\n配列\n\"\"\"\nA = [1,2,3,4,5]#配列の初期化\n\nB = [[1,2,3],[4,5,6],[7,8,9]]#2次元配列\n\nC = [区間(1,6) の要素 i について繰り返す i]#内包表記を用いて初期化できます.\n\nA.append(100)#配列の末尾に要素を追加します.\n表示する(A)\n\nA.prepend(200)#配列の先頭に要素を追加します.\n表示する(A)\n\nD = [1, 2, 3] + [4, 5, 6]#配列を連結します.\n表示する(D)\n\nD += [10, 20, 30]#代入演算子を使用できます.\n\nx = 2 * A#要素を2倍に増やします.\n表示する(x)\n\n削除 A[1]#配列から要素を削除します.\n表示する(A)\n\n表示する(A,\"の要素数 =\",A.要素数())#要素数を取得します.\n表示する(B,\"の要素数 =\",B.要素数())#要素数を取得します.\n\n#配列はfor-in文で列挙可能です.\nA の要素 a について繰り返す:\n    表示する(a)\n\n\"\"\"\n配列とその他のオブジェクトの結合\n\"\"\"\nA = [1,2,3]\nA += (10, 20, 30)#配列とタプルの結合\n表示する(A)\nA = [1,2,3]\nA += {2,3,4}#配列と集合型の結合\n表示する(A)\nA = [1,2,3]\nA += \"ABC\"#配列と文字列の結合\n表示する(A)\nA = [1,2,3]\nA += {\"A1\":1,\"A2\":2,\"A3\":3}#配列辞書型の結合(キーのみが使用されます)\n表示する(A)",
  "タプル": "\"\"\"\nタプル\n\"\"\"\nT = (1, 2, 3, 4, 5)#タプルの初期化\n\n表示する(T,\"の要素数 =\",T.要素数())\n\n#タプルはfor-in文で列挙可能です.\nT の要素 t について繰り返す:\n    表示する(t)\n\nU = (1, 2, 3) + (4, 5, 6)#タプルを連結します.\n表示する(U)\n\nU += (10, 20, 30)#代入演算子を使用できます.\n\nx = 2 * T#要素を2倍に増やします.\n表示する(x)",
  "辞書型": "\"\"\"\n辞書型の例\n辞書のキーは ほぼ 任意の値です.\nハッシュ可能でない値(配列や辞書)はキーとして使用できません.\n\"\"\"\n\nAngou = {\"A\":  100, \"B\":  123}#辞書型\n表示する(Angou[\"A\"])#文字列\"A\"でマッピングされた値を取得\nAngou[\"A\"] = 567#文字列\"A\"でマッピングされた値を更新\n表示する(Angou[\"A\"])\n\nd = 辞書([(\"sape\", 4139), (\"guido\", 4127), (\"jack\", 4098)])#タプルの配列から辞書を作成\n表示する(d)\n\n#辞書型はfor-in文で列挙可能です.\n#変数が1つの場合はキーと値がタプルとして展開される\nd の要素 x について繰り返す:\n    表示する(x)\n\n#変数が2つの場合はキーと値に展開される\nd の要素 key, value について繰り返す:\n    表示する(\"キー =\",key,\" 値 =\",value)",
  "集合型": "\"\"\"\n集合型\n\"\"\"\nS = {10,20,10,30,50,20}#集合の初期化\n\n表示する(S,\"の要素数 =\",S.要素数())#要素数を取得します.\n\nS.add(100)#集合に要素を追加します.\n表示する(S)\n\nS.remove(50)#集合から指定した要素を削除します.\n表示する(S)\n\nS.pop()#集合から要素を1つ削除します.\n表示する(S)\n\nS.clear()#集合からすべての要素を削除します.\n表示する(S)\n\nS = {10,20,10,30}\n\n#集合型はfor-in文で列挙可能です.\nS の要素 s について繰り返す:\n    表示する(s)\n\n\"\"\"\n集合型の演算\n\"\"\"\nx = {1,2,3,4,5}\ny = {2,3,4,90}\n表示する(x, \"&\", y,\"=\",x & y)#共通部分\n表示する(x, \"|\", y,\"=\",x | y)#和集合\n表示する(x, \"-\", y,\"=\",x - y)#差集合\n表示する(x, \"^\", y,\"=\",x ^ y)#対称差集合\n\na = {1,2}\nb = {0, 1, 2, 3}\n表示する(b, \">=\", a,\"=\",b >= a)#上位集合であるか\n表示する(a, \"<=\", b,\"=\",a <= b)#部分集合であるか\n\n#等価な集合に対してTrueを返す\n表示する(a, \">=\", a,\"=\",a >= a)\n表示する(a, \"<=\", a,\"=\",a <= a)\n\n#真部分集合であるかを判定するには>または<を使う\n表示する(a, \">\", a,\"=\",a > a)\n表示する(a, \"<\", a,\"=\",a < a)",
  "制御構文": "",
  "条件分岐文(if文)": "\"\"\"\n条件分岐文(if文)\n\"\"\"\nx = 10\n\n#if\nもし x == 10 ならば:\n    表示する(\"xは10\")\n\n#if-else\nもし x == 0 ならば:\n    表示する(\"x=\",x)\nそうでなければ:\n    表示する(\"xは0でない\")\n\n#if-elif-else\nもし x == 0 ならば:\n    表示する(\"xは0\")\nそうでなくもし x == 10 ならば:\n    表示する(\"xは10\")\nそうでなければ:\n    表示する(\"xは0でも10でもでない\")",
  "条件演算子(三項演算子)": "\"\"\"\n条件演算子(三項演算子)\n\"もし\" <条件> ならば <条件が真のときの値> \"そうでなければ\" <条件が偽のときの値>\n\"\"\"\n\nx = 10\ny = 20\nz = もし x == y ならば \"x==y\" そうでなければ \"x!=y\"\n表示する(z)#x!=y\n\n#これは以下の場合と等価です\nx = 10\ny = 20\nもし x == y ならば:\n    z = \"x==y\"\nそうでなければ:\n    z = \"x!=y\"\n表示する(z)#x!=y",
  "順次繰返し文(for文)": "\"\"\"\n順次繰返し文(for文)\n\"\"\"\nA = [10, 20, 30, 40, 50]\n\n\"\"\"\nカウンタ変数付きのfor文\n\"\"\"\ni を 0 から A.要素数() - 1 まで 1 ずつ増やしながら繰り返す:\n    表示する(A[i])\n\n\n\"\"\"\nfor-in文\n列挙可能なオブジェクトに対して使用することができます.\n\"\"\"\nA の要素 x について繰り返す:\n    表示する(x)",
  "条件繰返し文(while文)": "\"\"\"\n条件繰返し文(while文)\n\"\"\"\nx = 0\nx < 5 の間繰り返す:\n    表示する(x)\n    x += 1",
  "データ構造の操作": "",
  "スライスによる配列の操作": "\"\"\"\nスライスによる配列の操作\n\"\"\"\nl = [0, 10, 20, 30, 40, 50, 60]\n表示する(l)# [0, 10, 200, 300, 400, 50, 60]\n\nl[2:5] = [200, 300, 400]\n表示する(l)# [0, 10, 200, 300, 400, 50, 60]\n\nl[2:5] = [-2, -3]\n表示する(l)# [0, 10, -2, -3, 50, 60]\n\nl[2:4] = [2000, 3000, 4000, 5000]\n表示する(l)# [0, 10, 2000, 3000, 4000, 5000, 50, 60]\n\nl[2:6] = [20000]\n表示する(l)# [0, 10, 20000, 50, 60]",
  "スライスによる配列の要素の取得": "\"\"\"\nスライスによる配列の要素の取得\n\"\"\"\nl = [0, 10, 20, 30, 40, 50, 60]\n表示する(l)# [0, 10, 200, 300, 400, 50, 60]\n\n表示する(l[2:5])\nl[2:5] = [200, 300, 400]\n表示する(l)# [0, 10, 200, 300, 400, 50, 60]\n\n表示する(l[2:5])\nl[2:5] = [-2, -3]\n表示する(l)# [0, 10, -2, -3, 50, 60]\n\n表示する(l[2:4])\nl[2:4] = [2000, 3000, 4000, 5000]\n表示する(l)# [0, 10, 2000, 3000, 4000, 5000, 50, 60]\n\n表示する(l[2:6])\nl[2:6] = [20000]\n表示する(l)# [0, 10, 20000, 50, 60]",
  "「切り取り」による操作": "\"\"\"\n「切り取り」による操作\n「切り取り」はPythonにおけるsliceに相当します.\nイテレーション可能オブジェクトの範囲を指定するために\n使用します.\n\"\"\"\neven = 切り取り(1, 増分=2)\nodd = 切り取り(0, None, 2)\n表示する(even)\n表示する(odd)\nA = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n表示する(A[even])\n表示する(A[odd])",
  "データ構造の要素の判定": "\"\"\"\nデータ構造の要素の判定\nデータ構造に要素が含まれるかを判定します．Pythonの「in」または「not in」に相当します．\n<値> が <データ構造> の要素\n<値> が <データ構造> の要素でない\n\"\"\"\narray = [1,2,3,4,5]#配列\ntuple = (1, 2, 3, 4)#タプル\ndict = {\"A\":10,\"B\":20,\"C\":30}#辞書\nset = {1,2,3,4,5}#集合\n\n表示する(3 が array の要素)\n表示する(3 が array の要素でない)\n表示する(13 が array の要素)\n表示する(13 が array の要素でない)\n\n表示する(3 が tuple の要素)\n表示する(3 が tuple の要素でない)\n表示する(13 が tuple の要素)\n表示する(13 が tuple の要素でない)\n\n表示する(\"A\" が dict の要素)\n表示する(\"A\" が dict の要素でない)\n表示する(\"Z\" が dict の要素)\n表示する(\"Z\" が dict の要素でない)\n\n表示する(5 が set の要素)\n表示する(5 が set の要素でない)\n表示する(15 が set の要素)\n表示する(15 が set の要素でない)",
  "削除文": "\"\"\"\n削除文\nPythonにおけるdel文に相当します.\n\"\"\"\na = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nb = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n削除 a[2]\n表示する(a)#[0, 1, 3, 4, 5, 6, 7, 8, 9]\n\n削除 b[2:5]#配列の指定した範囲を削除\n表示する(b)#[0, 1, 5, 6, 7, 8, 9]\n\nobj = object()\nobj.x = 100\n削除 obj.x#プロパティを削除することもできます.",
  "区間": "\"\"\"\n区間\nPythonにおけるrangeに相当します.\n区間(開始,終了,増分)で指定します.\n\"\"\"\na = 区間(10)#終了のみを指定\nb = 区間(3, 10)#開始,終了を指定\nc = 区間(1, 10, 2)#開始,終了,増分を指定\n表示する(*a)#0 1 2 3 4 5 6 7 8 9\n表示する(*b)#3 4 5 6 7 8 9\n表示する(*c)#1 3 5 7 9\nc の要素 i について繰り返す:#繰り返すことも可能\n    表示する(i)",
  "配列内包表記": "\"\"\"\n配列内包表記\n配列を初期化するために使用します.\n\"\"\"\nA = [区間(1,10) の要素 i について繰り返す i * i]\n表示する(A)\n\n#これは以下の処理と等価です\nA = []\n区間(1,10) の要素 i について繰り返す:\n    A.append(i * i)\n表示する(A)",
  "文字列,配列,タプル,集合 変換": "\"\"\"\n文字列,配列,タプル,集合 変換\n文字列,配列,タプル,集合はそれぞれ変換することができます.\n\"\"\"\nArray = [1, 2, 3, 1, 2, 4, 5]\nTuple = (1, 2, 3, 1, 2, 4, 5)\nString = \"ABCDEFGABC\"\nSet = {1,2,3,4,3,2,1}\n\nArrayToTuple = タプル(Array)\nStringToTuple = タプル(String)\nSetToTuple = タプル(Set)\n\n表示する(ArrayToTuple)\n表示する(StringToTuple)\n表示する(SetToTuple)\n\nTupleToArray = 配列(Tuple)\nStringToArray = 配列(String)\nSetToArray = 配列(Set)\n\n表示する(TupleToArray)\n表示する(StringToArray)\n表示する(SetToArray)\n\nTupleToSet = 集合(Tuple)\nStringToSet = 集合(String)\nArrayToSet = 集合(Array)\n\n表示する(TupleToSet)\n表示する(StringToSet)\n表示する(ArrayToSet)",
  "列挙可能なオブジェクトの集約": "\"\"\"\n列挙可能なオブジェクトの集約\n「集約」はPythonにおける「zip」に相当します．\n複数の列挙可能なオブジェクトを1つにまとめて列挙することができます.\n\"\"\"\n\n果物 = [\"みかん\", \"りんご\", \"いちご\"]\n値段 = [200, 300, 400]\n\n集約(果物, 値段) の要素 果物の名前, 果物の値段 について繰り返す:\n    表示する(果物の名前, 果物の値段, \"円\")\n\n\n#要素数が異なる場合は少ない方の要素数までが返されます.\n地域 = [\"群馬県\", \"栃木県\", \"茨城県\", \"埼玉県\"]\n人口 = [192, 193, 285]\n\n集約(地域, 人口) の要素 地域名, 地域の人口 について繰り返す:\n    表示する(地域名, 地域の人口, \"人\")",
  "複数の変数への代入": "\"\"\"\n複数の変数への代入\n\"\"\"\n#左辺と右辺の要素数が一致していない場合はエラーになります.\na, b, c = 1, 2, 3\n表示する(a)#1\n表示する(b)#2\n表示する(c)#3\n\n#*を付けると余った要素が配列としてまとめて代入されます.\nx, y, *z = 1, 2, 3, 4, 5, 6\n表示する(x)#1\n表示する(y)#2\n表示する(z)#[3,4,5,6]\n\n#入れ子構造を作ることもできます.\n((a, b), c) = ((1, 2), 3)\n*(a, b), c = (1, 2), 3, 4\n\n#=で並べて複数の変数に同じ値を代入することもできます.\nX = Y = 123\n(d, e, f) = (g, h, i) = 1, 2, 3",
  "関数": "",
  "関数の定義": "\"\"\"\n関数の定義\n\"\"\"\n\n#引数なし\n関数 myFunc1():\n    表示する(\"Hello World\")\n\nmyFunc1()#関数 myFunc1を呼び出す\n\n\n#引数あり\n関数 myFunc2(x):\n    表示する(\"xの値は\", x, \"です\")\n\nmyFunc2(123)#関数 myFunc2を呼び出す",
  "関数の引数": "\"\"\"\n関数の引数\n関数の引数は「/」または「*」により,引数の記述方法に制約を持たせることができます.\n「/」より前にある引数は位置引数のみで指定することができ,\n「*」より後にある引数はキーワード引数のみで指定することができます.\n\n--------------------------------------------------------------\n|関数 f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):           |\n|     -----------     ------------    ----------             |\n|     |               |               |                      |\n|     --位置引数のみ  |               --キーワード引数のみ   |\n|                     --位置引数またはキーワード引数         |\n--------------------------------------------------------------\n\n\"\"\"\n\n関数 myFunc(a, b, /, c, d, *, e, f):\n    表示する(\"a=\",  a)\n    表示する(\"b=\",  b)\n    表示する(\"c=\",  c)\n    表示する(\"d=\",  d)\n    表示する(\"e=\",  e)\n    表示する(\"f=\",  f)\n\nmyFunc(10, 20, 40, d=30, f=50, e=70)",
  "可変長引数": "\"\"\"\n可変長引数\n引数に「*」を付けると,その引数は可変長引数となります.\n\"\"\"\n関数 f(x, *y):#引数yはタプル型として渡される\n    表示する(x)\n    表示する(y)\n\nf(9, 10, 1, 2, 3)\n\n\"\"\"\n*を列挙可能なオブジェクトの前に記述すると\n可変長引数として展開することができます.\n\"\"\"\nf(*[9, 10, 1, 2, 3])\nf(*{9, 10, 1, 2, 3})\n\n#辞書型の場合はキーのみが展開されます.\nf(*{\"s\":90, \"t\":91, \"u\":92})",
  "キーワード引数": "\"\"\"\nキーワード引数\n引数に「**」を付けると,その引数はキーワード引数となります.\nキーワード引数は,関数を呼び出す際に「<変数名>=<値>」の形で記述する必要があります.\nキーワード引数は辞書型として渡されます.\n\"\"\"\n関数 f(x, **y):\n    表示する(x)\n    表示する(y)\n\nf(123, s=90, t=91, u=92)\n\n\n\"\"\"\n**を辞書型の変数の前に記述すると\nキーワード引数として展開することができます.\n\"\"\"\nf(123,**{\"s\":90, \"t\":91, \"u\":92})",
  "デフォルト引数": "\"\"\"\nデフォルト引数\n関数の引数にはデフォルトの値を設定することができます.\n\"\"\"\n関数 f(x, y=123):\n    表示する(x)\n    表示する(y)\n\nf(200)#yの値は指定しなくてもよい\nf(200,300)#yが上書きされる\n\n#キーワード引数として書くこともできる\nf(200,y=300)\nf(x=200,y=300)\nf(x=200)",
  "ジェネレータ関数": "\"\"\"\nジェネレータ関数\n列挙可能なオブジェクトを返す関数です.\n「を一旦返す」はPythonにおける「yield」に相当します.\n「を一旦返す」を1つでも記述するとジェネレータ関数とみなされます.\n\"\"\"\n関数 gen():\n    表示する(\"gen1-A\")\n    100 を一旦返す\n    表示する(\"gen1-B\")\n    200 を一旦返す\n    表示する(\"gen1-C\")\n\ng1 = gen()\n表示する(g1)\ng1 の要素 x について繰り返す:\n    表示する(x)\n\n表示する(\"---------------\")\n\"\"\"\n関数「__next__」を呼ぶと次の「を一旦返す」まで処理が進められ,値が返ります.\n関数「__done__」でジェネレータの終了状態を把握することができます.\n\"\"\"\ng2 = gen()\n表示する(g2.__next__())#gen-A\n表示する(g2.__done__())#False\n表示する(g2.__next__())#gen-B\n表示する(g2.__done__())#False\n表示する(g2.__next__())#gen-C\n表示する(g2.__done__())#True",
  "ラムダ式": "\"\"\"\nラムダ式\nラムダ式は処理を持たない値を返すだけの関数です.\nPythonにおけるlambdaに相当します.\n\"\"\"\n\n#条件演算子を用いた奇数,偶数を判定するラムダ式\nf = ラムダ式 x : もし x % 2 == 0 ならば \"偶数\" そうでなければ \"奇数\"\n\n表示する(f)\n表示する(f(10))\n表示する(f(11))",
  "クラス": "",
  "クラスの定義": "\"\"\"\nクラスの定義\n\"\"\"\nクラス MyClass:\n\n    #コンストラクタ\n    関数 初期化(x):\n        self.c = x\n\n    関数 foo():\n        self.c を返す\n\n    #オブジェクトの文字列表現を返す関数\n    関数 __str__():\n        \"self.c=\" + 文字列(self.c) を返す\n\nx = MyClass(100)#MyClassのインスタンスを生成\n表示する(x)\n表示する(文字列(x))#__str__が呼ばれる\n表示する(x.foo())",
  "クラスの継承": "\"\"\"\nクラスの継承\n多重継承はできません.\n\"\"\"\nクラス A:\n    関数 初期化(x):\n        self.c = x\n\n    関数 foo():\n        self.c を返す\n\nクラス B(A):#クラスAを継承したクラス\n\n    関数 初期化(x):\n        super.初期化(x)#スーパークラスのコンストラクタを呼ぶ\n\n    関数 foo():\n        super.foo() * 2 を返す\n\na = A(100)\n表示する(a.foo())\n\nb = B(100)\n表示する(b.foo())",
  "型判定": "\"\"\"\n型判定\n値の型を判定するには,「型」関数を使用します.\nPythonにおけるtypeに相当します.\n\"\"\"\n表示する(型(123))\n表示する(型(\"ABC\"))\n表示する(型(True))\n表示する(型([1, 2, 3]))\n表示する(型((1, 2, 3)))\n表示する(型({1,2,3}))\n表示する(型({\"A\":100,\"B\":200,\"C\":300}))\n\n\n関数 f():\n    100 を一旦返す\n\n表示する(型(f))\n表示する(型(ラムダ式 x : x ** 2))\n表示する(型(f()))\n\n\nクラス MyClass:\n    関数 初期化():\n        self.x = 100\n\n表示する(型(MyClass))\n表示する(型(MyClass()))",
  "インスタンスに対する属性の設定": "",
  "算術演算子のオーバーロード": "\"\"\"\n算術演算子のオーバーロード\nクラスに特別な名前の関数を定義することで,インスタンスに対する\n算術演算の結果を定義することができます.\n\n以下は左辺がFooのインスタンス,右辺が数値の場合の算術演算を定義する例です.\n右辺がFooのインスタンス,左辺が数値の場合の算術演算を定義する場合は,\n\n__add__ -> __radd__ \n__sub__ -> __rsub__\n\nのように「r〇〇」とすればよい.\n\"\"\"\n\nクラス Foo:\n    関数 初期化(x):\n        self.x = x\n    関数 __add__(other):\n        表示する(\"__add__\")\n        Foo(self.x + other) を返す\n    関数 __sub__(other):\n        表示する(\"__sub__\")\n        Foo(self.x - other) を返す\n    関数 __mul__(other):\n        表示する(\"__mul__\")\n        Foo(self.x * other) を返す\n    関数 __truediv__(other):\n        表示する(\"__truediv__\")\n        Foo(self.x / other) を返す\n    関数 __floordiv__(other):\n        表示する(\"__floordiv__\")\n        Foo(self.x // other) を返す\n    関数 __mod__(other):\n        表示する(\"__mod__\")\n        Foo(self.x % other) を返す\n    関数 __pow__(other):\n        表示する(\"__pow__\")\n        Foo(self.x ** other) を返す\n    関数 __lshift__(other):\n        表示する(\"__lshift__\")\n        Foo(self.x << other) を返す\n    関数 __rshift__(other):\n        表示する(\"__rshift__\")\n        Foo(self.x >> other) を返す\n    関数 __and__(other):\n        表示する(\"__and__\")\n        Foo(self.x & other) を返す\n    関数 __xor__(other):\n        表示する(\"xor__\")\n        Foo(self.x ^ other) を返す\n    関数 __or__(other):\n        表示する(\"__or__\")\n        Foo(self.x | other) を返す\n    関数 toString():\n        self.x を返す\n\nx = Foo(100)\n表示する(x + 10)\n表示する(x - 10)\n表示する(x * 10)\n表示する(x / 10)\n表示する(x // 10)\n表示する(x % 10)\n表示する(x ** 10)\n表示する(x << 10)\n表示する(x >> 10)\n表示する(x & 10)\n表示する(x ^ 10)\n表示する(x | 10)",
  "比較演算子のオーバーロード": "\"\"\"\n比較演算子のオーバーロード\nクラスに特別な名前の関数を定義することで,インスタンスに対する\n比較演算の結果を定義することができます.\n\n以下はFooのインスタンスと数値の比較結果を定義する例です.\n\"\"\"\n\nクラス Foo:\n    関数 初期化(x):\n        self.x = x\n    関数 __lt__(other):\n        表示する(\"__lt__\")\n        self.x < other を返す\n    関数 __le__(other):\n        表示する(\"__le__\")\n        self.x <= other を返す\n    関数 __eq__(other):\n        表示する(\"__eq__\")\n        self.x == other を返す\n    関数 __ne__(other):\n        表示する(\"__ne__\")\n        self.x != other を返す\n    関数 __gt__(other):\n        表示する(\"__gt__\")\n        self.x > other を返す\n    関数 __ge__(other):\n        表示する(\"__ge__\")\n        self.x >= other を返す\n\nx = Foo(100)\n表示する(x < 10)\n表示する(x <= 10)\n表示する(x == 10)\n表示する(x != 10)\n表示する(x > 10)\n表示する(x >= 10)",
  "代入演算子のオーバーロード": "\"\"\"\n代入演算子のオーバーロード\nクラスに特別な名前の関数を定義することで,インスタンスに対する\n代入演算の結果を定義することができます.\n\n以下はFooのインスタンスと数値の代入演算の結果を定義する例です.\n\"\"\"\n\nクラス Foo:\n    関数 初期化(x):\n        self.__x = x\n    関数 __iadd__(other):\n        表示する(\"__iadd__\")\n        self.__x += other\n        self を返す\n    関数 __isub__(other):\n        表示する(\"__isub__\")\n        self.__x -= other\n        self を返す\n    関数 __imul__(other):\n        表示する(\"__imul__\")\n        self.__x *= other\n        self を返す\n    関数 __itruediv__(other):\n        表示する(\"__itruediv__\")\n        self.__x /= other\n        self を返す\n    関数 __ifloordiv__(other):\n        表示する(\"__ifloordiv__\")\n        self.__x //= other\n        self を返す\n    関数 __imod__(other):\n        表示する(\"__imod__\")\n        self.__x %= other\n        self を返す\n    関数 __ipow__(other):\n        表示する(\"__ipow__\")\n        self.__x **= other\n        self を返す\n    関数 __ilshift__(other):\n        表示する(\"__ilshift__\")\n        self.__x <<= other\n        self を返す\n    関数 __irshift__(other):\n        表示する(\"__irshift__\")\n        self.__x >>= other\n        self を返す\n    関数 __iand__(other):\n        表示する(\"__iand__\")\n        self.__x &= other\n        self を返す\n    関数 __ixor__(other):\n        表示する(\"__ixor__\")\n        self.__x ^= other\n        self を返す\n    関数 __ior__(other):\n        表示する(\"__ior__\")\n        self.__x |= other\n        self を返す\n\nx = Foo(100)\nx += 1\nx = Foo(100)\nx -= 1\nx = Foo(100)\nx *= 1\nx = Foo(100)\nx /= 1\nx = Foo(100)\nx //= 1\nx = Foo(100)\nx %= 1\nx = Foo(100)\nx **= 1\nx = Foo(100)\nx <<= 1\nx = Foo(100)\nx >>= 1\nx = Foo(100)\nx &= 1\nx = Foo(100)\nx ^= 1\nx = Foo(100)\nx |= 1",
  "前置演算子のオーバーロード": "\"\"\"\n前置演算子のオーバーロード\nクラスに特別な名前の関数を定義することで,インスタンスに対する\n前置演算の結果を定義することができます.\n\n以下はFooのインスタンスの前置演算の結果を定義する例です.\n\"\"\"\n\nクラス Foo:\n    関数 初期化(x):\n        self.__x = x\n    関数 __neg__():\n        表示する(\"__neg__\")\n        Foo(-self.__x) を返す\n    関数 __pos__():\n        表示する(\"__pos__\")\n        Foo(self.__x) を返す\n    関数 __invert__():\n        表示する(\"__invert__\")\n        Foo(~self.__x) を返す\n\nx = Foo(100)\na = -x\na = +x\na = ~x",
  "インスタンスを列挙可能にする": "\"\"\"\nクラスのインスタンスを列挙可能にするには,\n特別な名前の関数をクラスに実装する必要があります.\n\n以下は線形リスト「MyListクラス」のインスタンスを\n列挙可能にする例です.\n\"\"\"\n\nクラス MyList:\n    関数 初期化():\n        self.elem = []#リストの要素を格納する配列\n        self.itr_pos = 0#次に返す値のポジション\n        self.done = False#列挙の終了状態を示すフラグ\n\n    #線形リストに要素を追加します\n    関数 追加(x):\n        self.elem.append(x)\n\n    #次の値を返す関数\n    関数 __next__():\n        もし self.itr_pos < self.elem.要素数() ならば:\n            p = self.itr_pos\n            self.itr_pos += 1\n            self.done = False#列挙中の状態\n            self.elem[p] を返す\n        そうでなければ:\n            self.done = True#列挙が終了した状態にする\n            self.itr_pos = 0\n            None を返す\n\n    #列挙が終了したかを示す値を返す関数\n    関数 __done__():\n        self.done を返す\n\n\nlist = MyList()\nlist.追加(100)\nlist.追加(200)\nlist.追加(300)\n\nlist の要素 x について繰り返す:\n    表示する(x)\n\n表示する(*list)#可変長引数として展開することもできます.",
  "その他": "",
  "mathオブジェクト": "\"\"\"\nmathオブジェクト\n\"\"\"\n表示する(math)\n表示する(math.max(10,20,30))\n表示する(math.min(10,20,30))\n表示する(math.abs(-100))\n表示する(math.sqrt(2))\n表示する(math.floor(0.5))\n表示する(math.round(0.5))\n表示する(math.sin(0.5))\n表示する(math.cos(0.5))\n表示する(math.tan(0.5))\n表示する(math.E)\n表示する(math.ネイピア数)\n表示する(math.PI)\n表示する(math.円周率)",
  "ソート関数": "\"\"\"\nソート関数\n列挙可能なオブジェクトの要素をソートします.戻り値としてソート済みの配列を返します.\n元の列挙可能なオブジェクトの順序は変化させません.\n\n関数 ソート(itrable, 反転=False)\n・itrable：コンソールに表示する値\n・反転：Trueの場合は降順ソート,Falseの場合は昇順ソートになる\n\"\"\"\nHairetsu = [5,7,4,2,3,8,1]\n表示する(ソート(Hairetsu))\n表示する(ソート(Hairetsu,反転=True))\n\nmoji = \"TSUCHINOKO\"\n表示する(ソート(moji))\n表示する(ソート(moji,反転=True))\n\nTuple = (5,7,4,2,3,8,1)\n表示する(ソート(Tuple))\n表示する(ソート(Tuple,反転=True))\n\nJisyo = {\"C\":  100,\"A\":  123, \"B\":  123}\n表示する(ソート(Jisyo))\n表示する(ソート(Jisyo,反転=True))\n\nSyugou = {5,7,4,2,3,8,1}\n表示する(ソート(Syugou))\n表示する(ソート(Syugou,反転=True))",
  "randomクラス": "\"\"\"\nrandomクラスは擬似乱数を生成するメソッドを提供します.\n\"\"\"\nランダム = random()\n\n#[0,1)の乱数を返す\n表示する(ランダム.random())\n\n#min<=x<=maxを満たす整数乱数を返す\n表示する(ランダム.randint(10,20))\n\n#区間(開始,終了,ステップ)の要素からランダムに選ばれた数を返す\n表示する(ランダム.randrange(0,100,10))\n\n\n#シードを設定することができます.\nシードランダム = random(123)\n\n表示する(シードランダム.random())#常に同じ値になる\n表示する(シードランダム.randint(10,20))#常に同じ値になる\n表示する(シードランダム.randrange(0,100,10))#常に同じ値になる",
  "datetimeクラス": "\"\"\"\ndatetimeクラスは日付を表すクラスです.\n\"\"\"\n\n日付 = datetime()\n\n表示する(日付.年)\n表示する(日付.月)\n表示する(日付.日)\n表示する(日付.曜日)\n表示する(日付.時)\n表示する(日付.分)\n表示する(日付.秒)\n\n表示する(\"今日は\",日付.年,\"年\",日付.月,\"月\",日付.日,\"日です\")",
  "可視化関数の活用例": "\"\"\"\n可視化関数の活用例\n\"\"\"\nプログラミング言語のシェア = {\n  \"Python\": 30.3,\n  \"Java\": 22.2,\n  \"C++\": 13,\n  \"Ruby\": 10.6,\n  \"Javascript\": 5.2,\n  \"C#\": 5,\n  \"C\": 4.1,\n  \"PHP\": 3.3,\n  \"Perl\": 1.6,\n  \"Go\": 1.5,\n  \"Haskell\": 1.2,\n  \"Scala\": 1,\n  \"Objective-C\": 0.4,\n  \"Clojure\": 0.2,\n  \"Bash\": 0.1,\n  \"Lua\": 0.04,\n  \"TCL\": 0.03\n}#でたらめなデータです\n\n#凡例付きのドーナツグラフとして可視化\n可視化(プログラミング言語のシェア,種類=\"ドーナツグラフ\",凡例=True)",
  "描画関数": "\"\"\"\n描画関数\n\"\"\"\n描画領域を開く(300,200)#描画領域を開くために呼び出す\n\n#図形を描画する\n図形の色(\"orange\")#図形の色は図形の色で設定する\n線の幅(1)#図形の線の幅は「線の幅」で設定する\n線の色(rgb(0,0,255))#図形の線の色は「線の色」で設定する\n\n円を描画(50,50,30)\n\n図形の色(\"yellow\")#図形の色を途中で変更する\n\n楕円を描画(120,50,20,40)\n\n線の色(\"rgb(30,223,255)\")#線の色を途中で変更する\n\n四角形を描画(160,50,40,40)\n\n#直線を描画する\n線の色(\"green\")#直線の色は「線の色」で設定する\n線の幅(5)#直線の幅は「線の幅」で設定する\n直線を描画(210,100,290,30)\n\n#文字列を描画する\n図形の色(\"red\")#文字列の色は「図形の色」で設定する\n文字列を描画(90,170,\"ABC\",60)",
  "描画関数の使用例(モンテカルロ法)": "\"\"\"\nモンテカルロ法\n\"\"\"\nR = 250#円の半径\n\n描画領域を開く(R,R)\n背景の色(\"rgb(255,255,255)\")\n線の色(\"rgb(0,0,0)\")\n図形の色(\"rgb(255,255,255)\")\n楕円を描画(0,0,R,R)\n\nkaisu = 1000#試行回数\ninside = 0\n\ni を 1 から kaisu まで 1 ずつ増やしながら繰り返す:\n    x = 実数乱数(0,1)\n    y = 実数乱数(0,1)\n    もし x * x + y * y <= 1 ならば:\n        線の色(\"rgb(255,0,0)\")\n        図形の色(\"rgb(255,0,0)\")\n        inside = inside + 1\n    そうでなければ:\n        線の色(\"rgb(0,0,255)\")\n        図形の色(\"rgb(0,0,255)\")\n    楕円を描画(R * x,R * y,1,1)\n\n表示する(\"円の内側:\",  inside,\"回\")\n表示する(\"円の外側:\",  kaisu - inside,\"回\")\n表示する(\"円周率の近似値は\", 4.0 * inside / kaisu)",
  "描画関数の使用例(コッホ曲線)": "\"\"\"\nコッホ曲線を描画するプログラム\n\"\"\"\n関数 コッホ(n, angle, len):\n    もし n <= 0 ならば:\n        x = len × cos(angle) + 原点[\"x\"]\n        y = len × sin(angle) + 原点[\"y\"]\n        直線を描画(原点[\"x\"],(200 - 原点[\"y\"]),x,(200 - y))\n        原点[\"x\"] = x\n        原点[\"y\"] = y\n        1 を返す\n\n    コッホ(n - 1,angle,len)\n    コッホ(n - 1,angle + 60,len)\n    コッホ(n - 1,angle - 60,len)\n    コッホ(n - 1,angle,len)\n\n原点 = { \"x\":15, \"y\":90 }\n\n描画領域を開く(300,150)\nコッホ(3,0,10)",
  "描画関数の使用例(ランダムに円を描画)": "\"\"\"\nランダムに円を描画\n\"\"\"\n\n描画領域を開く(300,300)\n図形の色(\"transparent\")\n\nTrue の間繰り返す:\n    r = 整数乱数(0,255)\n    g = 整数乱数(0,255)\n    b = 整数乱数(0,255)\n    線の色(rgb(r,g,b))\n    半径 = 整数乱数(1,30)\n    円を描画(整数乱数(1,300),整数乱数(1,300),半径)"
};
